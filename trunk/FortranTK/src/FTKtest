#!/usr/bin/env ruby
#
# $Id$
#
# Generates a Fortran 90 code which runs all the mobility
# test suites in this directory (or only those test suites
# specified on the command line).


def checkForCompiler
 unless ENV['F9X']
  puts <<-ENVIRON

Fortran compiler environment variable 'F9X' not set:

 for bourne-based shells: export F9X=lf95 (in .profile)
      for c-based shells: setenv F9X lf95 (in .login)
             for windows: set F9X=C:\Program Files\lf95 (in autoexec.bat)

  ENVIRON
  exit 1
 end
end

# optionally, handle test suites given as command line arguments:

def checkCommandLineFor allTestSuites

 return allTestSuites if $*.empty?

 testSuitesNotFound = $* - ( $* & allTestSuites )
 if testSuitesNotFound.empty?
  return $*
 else
  print "\n Error: could not find test suite:"
  testSuitesNotFound.each {|testSuiteNotFound| print " #{testSuiteNotFound}"}
  print "\n\n Test suites available in this directory:\n"
  allTestSuites.each { |testSuite| print "  #{testSuite}\n" }
  print "\nUsage: #{File.basename $0} [test names (w/o TS.ftk suffix)]\n\n"
  exit 1
 end
end

# create the Fortran9X program which calls all the test suites:

def writeTestRunner testSuites

 testRunner = File.new "TestRunner.f90", "w"

 testRunner.puts <<-HEADER
! TestRunner.f90 - runs Fortran mobility test suites
!
! [Dynamically generated by #{File.basename $0} Ruby script #{Time.now}.]

program TestRunner

 HEADER

 testSuites.each { |testSuite| testRunner.puts " use #{testSuite}TestSuite" }

 testRunner.puts <<-DECLARE

 implicit none

 integer :: numTests, numAsserts, numAssertsTested, numFailures
 DECLARE

 testSuites.each do |testSuite|
  testRunner.puts <<-TRYIT

 print *, ""
 print *, "#{testSuite} test suite:"
 call TS#{testSuite}( numTests, numAsserts, numAssertsTested, numFailures )
 print *, "Completed", numTests-numFailures, "of", numTests,&
   "tests comprising", numAssertsTested, "of", numAsserts, "possible asserts."
  TRYIT
 end

 testRunner.puts "\n print *, \"\""
 testRunner.puts "\nend program TestRunner"
 testRunner.close

end

class Assert
 def IsRealEqual
  /(IsRealEqual)\s*\((.*),(.*)\)/
  condition = ".not.(#$3+2*spacing(real(#$3)).ge.#$2.and.#$3-2*spacing(real(#$3)).le.#$2)"
  message = "#$2,\"is not\",#$3,\"within\",2*spacing(real(#$3))"
  expandAssert( $1, condition, message, lineNumber, name, testSuite )
 end
 def IsEqualWithin
  /(IsEqualWithin)\s*\((.*),(.*),(.*)\)/
  condition = ".not.(#$3+#$4.ge.#$2.and.#$3-#$4.le.#$2)"
  message = "#$2,\"is not\",#$3,\"within\",#$4"
  expandAssert( $1, condition, message, lineNumber, name, testSuite )
 end
 def IsEqual
  /(IsEqual)\s*\((.*),(.*)\)/
  condition = ".not.(#$2==#$3)"
  message = "#$2, \"is not\", #$3"
  expandAssert( $1, condition, message, lineNumber, name, testSuite )
 end
 def IsTrue
  /(IsTrue)\s*\((.*)\)/
  condition = ".not.(#$2)"
  message = "#$2, \"is not true\""
  expandAssert( $1, condition, message, lineNumber, name, testSuite )
 end
 def IsFalse
  /(IsFalse)\s*\((.*)\)/
  condition = "#$2"
  message = "#$2, \"is not false\""
  expandAssert( $1, condition, message, lineNumber, name, testSuite )
 end
 def expandAssert( name, condition, message, lineNumber, testName, testSuite )
  puts "\n  ! #{name} assertion"
  puts "  numAsserts = numAsserts + 1"
  puts "  if (noAssertFailed) then"
  puts "   if (#{condition})then"
  puts "    print *, \"  Test #{testName}: #{name} FAILED (Line #{lineNumber} of #{testSuite}TS.ftk)\""
  puts "    print *, \"   \",#{message}"
  puts "    noAssertFailed = .false."
  puts "    numFailures = numFailures + 1"
  puts "   else"
  puts "    numAssertsTested = numAssertsTested + 1"
  puts "   endif"
  puts "  endif"
 end
end

class TestSuite < File

 def initialize name

  super(name+"TS.f90","w")
  @tests, @setup, @teardown = [], [], []

  puts <<-TOP
! #{name}TS.f90 - a Fortran mobility test suite
!
! [dynamically generated from #{name}TS.ftk
!  by #{File.basename $0} Ruby script #{Time.now}]

module #{name}TestSuite

 use #{name}

 implicit none

 private

 public :: TS#{name}

 logical :: noAssertFailed

 integer :: numTests          = 0
 integer :: numAsserts        = 0
 integer :: numAssertsTested  = 0
 integer :: numFailures       = 0

  TOP
 end

 def addtoSetup
  @setup.push($_) until gets=~/endSetup/
 end

 def addtoTeardown
  @teardown.push($_) until gets=~/endTeardown/
 end

 def aTest name

  # NOTE: need testSuiteName and lineNumber in parsed ftk file
  @tests.push(name)
  puts " subroutine Test#{testName}\n\n"
p
  until gets=~/endTest/
   case $_
    when /(IsRealEqual)\s*\((.*),(.*)\)/
     condition = ".not.(#$3+2*spacing(real(#$3)).ge.#$2.and.#$3-2*spacing(real(#$3)).le.#$2)"
     message = "#$2,\"is not\",#$3,\"within\",2*spacing(real(#$3))"
     expandAssert( $1, condition, message, lineNumber, name, testSuite )
    when /(IsEqualWithin)\s*\((.*),(.*),(.*)\)/
     condition = ".not.(#$3+#$4.ge.#$2.and.#$3-#$4.le.#$2)"
     message = "#$2,\"is not\",#$3,\"within\",#$4"
     expandAssert( $1, condition, message, lineNumber, name, testSuite )
    when /(IsEqual)\s*\((.*),(.*)\)/
     condition = ".not.(#$2==#$3)"
     message = "#$2, \"is not\", #$3"
     expandAssert( $1, condition, message, lineNumber, name, testSuite )
    when /(IsTrue)\s*\((.*)\)/
     condition = ".not.(#$2)"
     message = "#$2, \"is not true\""
     expandAssert( $1, condition, message, lineNumber, name, testSuite )
    when /(IsFalse)\s*\((.*)\)/
     condition = "#$2"
     message = "#$2, \"is not false\""
     expandAssert( $1, condition, message, lineNumber, name, testSuite )
    else
     puts $_
   end
  end

  puts "\n  numTests = numTests + 1\n\n"
  puts " end subroutine Test#{testName}\n\n"

 end

 def close

  puts "\n subroutine Setup"
  puts "  noAssertFailed = .true."
  puts @setup
  puts " end subroutine Setup\n\n"

  puts "\n subroutine Teardown"
  puts @teardown
  puts " end subroutine Teardown\n\n"

  puts <<-NEXTONE

 subroutine TS#{testSuite}( nTests, nAsserts, nAssertsTested, nFailures )

  integer :: nTests
  integer :: nAsserts
  integer :: nAssertsTested
  integer :: nFailures

  continue
  NEXTONE

  @tests.each do |test|
   puts "\n  call Setup"
   puts "  call Test#{test}"
   puts "  call Teardown"
  end

  puts <<-LASTONE

  nTests          = numTests
  nAsserts        = numAsserts
  nAssertsTested  = numAssertsTested
  nFailures       = numFailures

 end subroutine TS#{testSuite}

end module #{testSuite}TestSuite
  LASTONE

  super

 end

end

####### script starts here #######

checkForCompiler

# find all the test suites in the current directory:

testSuites = Dir["*TS.ftk"]
testSuites.each { |testSuite| testSuite.chomp! "TS.ftk" }
testSuites = checkCommandLineFor testSuites

writeTestRunner testSuites

# convert each *TS.ftk file into pure Fortran9x:

testSuites.each do |testSuite|

 testSuiteF90 = TestSuite.new(testSuite)

 testName   = ""
 lineNumber = 0

 File.open(testSuite+"TS.ftk") do |$stdin|
  testSuiteF90.puts $_ until gets=~/begin(Setup|Teardown|Test)/
  testSuiteF90.puts " contains\n\n"
  loop do
   case $_
    when /beginSetup/
     testSuiteF90.addtoSetup
    when /beginTeardown/
     testSuiteF90.addtoTeardown
    when /beginTest \s*(.*)/
     testSuiteF90.aTest($1)
    when /beginTest/
     $stderr.print "No test name following beginTest: " \
                   "Line #{lineNumber} of #{testSuite}TS.ftk\n"
     exit 1
    when /Is(RealEqual|Equal|False|True|EqualWithin)/
     $stderr.print "Error: assertion outside of a test block: " \
                   "Line #{lineNumber} of #{testSuite}TS.ftk\n"
     exit 1
    else
     puts $_
   end
   break unless gets
  end

 end

 testSuiteF90.close

end


# Comple, link, and run:

sources = testSuites.join(".f90 ") + ".f90"
tests   = testSuites.join("TS.f90 ") + "TS.f90"

compile = "#{ENV['F9X']} -o TestRunner #{sources} #{tests} TestRunner.f90"

if system(compile)
 system "./TestRunner" if File.exists? "TestRunner"
else
 print "\nCompile failed.\n"
end
