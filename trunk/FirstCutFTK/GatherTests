#!/usr/bin/env ruby
#
# $Id$
#
# Generates a Fortran 90 code which runs all the mobility tests
# in this directory (or only those tests specified on the command
# line).

def printUsage
 puts <<-USAGE

 Usage: #{File.basename $0} [test names (w/o Test.F90 suffix)]

USAGE
end

if ARGV[0]
 tests = ARGV
else
 tests = Dir["*Test.F90"]
 tests.each { |f| f.chomp! "Test.F90" }
end

testsNotFound = []

tests.each do |test|
 testsNotFound.push(test) unless FileTest.exists?(test+"Test.F90")
end

if (!testsNotFound.empty?)
 print "\n"
 print " Error: could not find test"
 print "s" unless testsNotFound.size == 1
 print ":"
 testsNotFound.each {|test| print " #{test}"}
 print "\n\n"
 print " Tests available in this directory:\n"
 Dir["*Test.F90"].each { |f| print "  #{f.chomp('Test.F90')}\n" }
 printUsage
 File.delete "TestRunner.f90" if FileTest.exists? "TestRunner.f90"
 exit 1
end

testRunner = File.new "TestRunner.f90", "w"

testRunner.puts <<-HEADER
! TestRunner.f90 - runs Fortran mobility tests
!                  [generated by #{File.basename $0} Ruby script]
program TestRunner

 use FTK

 implicit none

 continue

HEADER

tests.each do |testSuiteName|
 testRunner.puts " print *, \"\""
 testRunner.puts " print *, \"#{testSuiteName}Test:\""
 testRunner.puts " call Test#{testSuiteName}"
 testRunner.puts ""
end

testRunner.puts <<-TAILER
end program TestRunner
TAILER

testMakefile = File.new "TestBits.mk", "w"

sources = []
tests.each do |test|
 sources.push(test) if FileTest.exists?(test+".f90")
end

sourceFiles = sources.join(".f90 ") + ".f90"

testFiles = tests.join("Test.f90 ") + "Test.f90"

testMakefile.puts <<-MAKEBITS

EXECUTABLE = TestRunner

SOURCES = #{sourceFiles}

TESTS   = #{testFiles}

RUNNER  = TestRunner.f90

MAKEBITS

tests.each do |testSuiteName|

 testCode = File.new(testSuiteName+"Test.f90","w")

 inTest = false

 lineNumber = 0

 IO.foreach(testSuiteName+"Test.F90") do |line|

  lineNumber += 1

  case line
   when /FTKSetup/
    testCode.puts "! BEGIN FTKSetup macro expansion"
   when /FTKTestSub \s*(.*)\s*\((.*)\)/
    testName = $1
    testCode.puts "! BEGIN FTKTestSub macro expansion"
    if inTest
     testCode.puts "! END   A Test\n\n\n"
     inTest = false
    end
    testCode.puts "! BEGIN A Test ======================"
    inTest = true
    testCode.puts "call #{testName} ( #$2 )"
    testCode.puts "! END   FTKTestSub macro expansion\n"
   when /IsFalse\((.*)\)/
    testCode.puts "! BEGIN IsFalse macro expansion"
    testCode.puts "if (#$1) then"
    testCode.puts " testKitHasFailed = .true."
    testCode.puts " print *, \"FAILURE: #$1 (\", #$1, \") is not false\""
    testCode.puts "endif"
    testCode.puts "! END   IsFalse macro expansion\n\n"
   when /IsTrue\((.*)\)/
    testCode.puts "! BEGIN IsTrue macro expansion"
    testCode.puts "if (.not.(#$1)) then"
    testCode.puts " testKitHasFailed = .true."
    testCode.puts " print *, \"FAILURE: #$1 (\", #$1, \") is not true\""
    testCode.puts "endif"
    testCode.puts "! END   IsTrue macro expansion\n\n"
   when /IsEqual\((.*),(.*)\)/
    testCode.puts "! BEGIN IsEqual macro expansion"
    testCode.puts "if (.not.(#$1==#$2)) then"
    testCode.puts " testKitHasFailed = .true."
    testCode.puts " print *, \"FAILURE: #$1 (\", #$1, \") is not #$2\""
    testCode.puts "endif"
    testCode.puts "! END   IsEqual macro expansion\n\n"
   when /IsFloatEqual\((.*),(.*),(.*)\)/
    testCode.puts "! BEGIN IsFloatEqual macro expansion"
    testCode.puts "if (.not.(#$2+#$3.ge.#$1.and.#$2-#$3.le.#$1))then"
    testCode.puts " testKitHasFailed = .true."
    testCode.puts " print *, \"FAILURE: #$1 (\",#$1,\") is not #$2 within #$3\""
    testCode.puts "endif"
    testCode.puts "! END   IsFloatEqual macro expansion\n\n"
   else
    testCode.puts line
  end
 end
 testCode.close
end
