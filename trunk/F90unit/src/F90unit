#!/usr/bin/env ruby
#
# $Id$
#
# Generates a Fortran 90 code which runs all the mobility
# test suites in this directory (or only those test suites
# specified on the command line).

#######################
#require 'FTKfunctions'

def checkForCompiler
 unless ENV['F9X']
  puts <<-ENVIRON

Fortran compiler environment variable 'F9X' not set:

 for bourne-based shells: export F9X=lf95 (in .profile)
      for c-based shells: setenv F9X lf95 (in .login)
             for windows: set F9X=C:\Program Files\lf95 (in autoexec.bat)

  ENVIRON
  exit 1
 end
 puts
end


def parseCommandLine

 allTestSuites = Dir["*TS.ftk"]
 if (allTestSuites.size==0) then
  $stderr.puts "   *Error: no test suites found in this directory\n\n"
  exit 1
 end
 allTestSuites.each { |suiteName| suiteName.chomp! "TS.ftk" }

 return allTestSuites if $*.empty?

 testSuitesNotFound = $* - ( $* & allTestSuites )
 if testSuitesNotFound.empty?
  return $*
 else
  print "\n Error: could not find test suite:"
  testSuitesNotFound.each {|testSuiteNotFound| print " #{testSuiteNotFound}"}
  print "\n\n Test suites available in this directory:\n"
  allTestSuites.each { |testSuite| print "  #{testSuite}\n" }
  print "\nUsage: #{File.basename $0} [test names (w/o TS.ftk suffix)]\n\n"
  exit 1
 end

end


def writeTestRunner testSuites

 File.delete("TestRunner.f90") if File.exists?("TestRunner.f90")
 testRunner = File.new "TestRunner.f90", "w"

 testRunner.puts <<-HEADER
! TestRunner.f90 - runs Fortran mobility test suites
!
! [Dynamically generated by #{File.basename $0} Ruby script #{Time.now}.]

program TestRunner

 HEADER

 testSuites.each { |testSuite| testRunner.puts " use #{testSuite}TS" }

 testRunner.puts <<-DECLARE

 implicit none

 integer :: numTests, numAsserts, numAssertsTested, numFailures
 real :: time
 DECLARE

 testSuites.each do |testSuite|
  testRunner.puts <<-TRYIT

 print *, ""
 print *, "#{testSuite} test suite:"
 call TS#{testSuite}( numTests, &
        numAsserts, numAssertsTested, numFailures )
 print *, "Passed", numAssertsTested, "of", numAsserts, &
          "possible asserts comprising", &
           numTests-numFailures, "of", numTests, "tests." 
  TRYIT
 end

 testRunner.puts "\n print *, \"\""
 testRunner.puts "\nend program TestRunner"
 testRunner.close
 File.chmod(0444,"TestRunner.f90")
end

def syntaxError( message, testSuite )
 $stderr.puts "\n   *Error: #{message} [#{testSuite}TS.ftk:#$.]\n\n"
 exit 1
end

def warning( message, testSuite )
 $stderr.puts "\n *Warning: #{message} [#{testSuite}TS.ftk:#$.]"
end

def runTests testSuites

 puts

 sources = testSuites.join(".f90 ") + ".f90"
 tests   = testSuites.join("TS.f90 ") + "TS.f90"

 depends = Array.new

 testSuites.each do |testSuite|
  IO.foreach(testSuite+".f90") do |$_|
   next unless /^\s*use\s+(\w+)/i
   depends << $1
  end
 end

 testSuites.each do |testSuite|
  IO.foreach(testSuite+"TS.f90") do |$_|
   next unless /^\s*use\s+(\w+)/i
   depends << $1
  end
 end

 depends.uniq!
 depends = depends - testSuites
 dependents = depends.join(".f90 ") + ".f90" unless depends.size == 0
 
 compile = "#{ENV['F9X']} #{ENV['F9X_LDFLAGS']} -o TestRunner #{dependents} #{sources} #{tests} TestRunner.f90"

 if system(compile)
  system "./TestRunner"
 else
  print "\nCompile failed.\n"
 end

end

# set some regular expressions:
$keyword = /(begin|end)(Setup|Teardown|Test)|Is(RealEqual|Equal|False|True|EqualWithin)\(.*\)/i
$commentLine = /^\s*!/

####################
#require 'TestSuite'

###################
# require 'Asserts'

module Asserts

 $assertRegEx = /Is(RealEqual|False|True|EqualWithin|Equal)\(.*\)/i

 def istrue(line)
  line=~/\((.+)\)/
  @type = 'IsTrue'
  @condition = ".not.(#$1)"
  @message = "\"#$1 is not true\""
  syntaxError("invalid body for #@type",@testSuite) unless $1=~/\S+/
  writeAssert
 end

 def isfalse(line)
  line=~/\((.+)\)/
  @type = 'IsFalse'
  @condition = "#$1"
  @message = "\"#$1 is not false\""
  syntaxError("invalid body for #@type",@testSuite) unless $1=~/\S+/
  writeAssert
 end

 def isrealequal(line)
  line=~/\((.+),(.+)\)/
  @type = 'IsRealEqual'
  @condition = ".not.(#$2+2*spacing(real(#$2)).ge.#$1 &\n             .and.#$2-2*spacing(real(#$2)).le.#$1)"
  @message = "\"#$1 (\",#$1,\") is not\",#$2,\"within\",2*spacing(real(#$2))"
  syntaxError("invalid body for #@type",@testSuite) unless $&
  writeAssert
 end

 def isequalwithin(line)
  line=~/\((.+),(.+),(.+)\)/
  @type = 'IsEqualWithin'
  @condition = ".not.(#$2+#$3.ge.#$1 &\n             .and.#$2-#$3.le.#$1)"
  @message = "\"#$1 (\",#$1,\") is not\",#$2,\"within\",#$3"
  syntaxError("invalid body for #@type",@testSuite) unless $&
  writeAssert
 end

 def isequal(line)
  line=~/\((.+),(.+)\)/
  @type = 'IsEqual'
  @condition = ".not.(#$1==#$2)"
  @message = "\"#$1 (\",#$1,\") is not\", #$2"
  syntaxError("invalid body for #@type",@testSuite) unless $&
  writeAssert
 end

 def writeAssert
  puts "\n  ! #@type assertion"
  puts "  numAsserts = numAsserts + 1"
  puts "  if (noAssertFailed) then"
  puts "   if (#@condition) then"
  puts "    print *, \" *#@type failed* in test #@testName &\n" \
  "                       &[#{@testSuite}TS.ftk:#$.]\""
  puts "    print *, \"  \", #@message"
  puts "    print *, \"\""
  puts "    noAssertFailed = .false."
  puts "    numFailures    = numFailures + 1"
  puts "   else"
  puts "    numAssertsTested = numAssertsTested + 1"
  puts "   endif"
  puts "  endif"
 end

end

######################

class TestSuite < File

 include Asserts

 def initialize suiteName

  @suiteName = suiteName
  File.delete(suiteName+"TS.f90") if File.exists?(suiteName+"TS.f90")
  super(suiteName+"TS.f90","w")
  @tests, @setup, @teardown = [], [], []

  puts <<-TOP
! #{@suiteName}TS.f90 - a Fortran mobility test suite for #{@suiteName}.f90
!
! [dynamically generated from #{@suiteName}TS.ftk
!  by #{File.basename $0} Ruby script #{Time.now}]

module #{@suiteName}TS

 use #{@suiteName}

 implicit none

 private

 public :: TS#{@suiteName}

 logical :: noAssertFailed

 integer :: numTests          = 0
 integer :: numAsserts        = 0
 integer :: numAssertsTested  = 0
 integer :: numFailures       = 0

  TOP
 end

 def addtoSetup ftkFile
  @setup.push($_) until ftkFile.gets=~/endSetup/i
 end

 def addtoTeardown ftkFile
  @teardown.push($_) until ftkFile.gets=~/endTeardown/i
 end

 def aTest testName, testSuite, ftkFile
  @testName, @testSuite = testName, testSuite
  @tests.push(testName)
  syntaxError("test name #@testName not unique",@testSuite) if (@tests.uniq!)

  puts " subroutine Test#{testName}\n\n"

  numOfAsserts = 0
  until ftkFile.gets=~/endTest/i
   case $_
   when $commentLine
    puts $_
   when /Is(RealEqual|False|True|EqualWithin|Equal)/i
    numOfAsserts += 1
    send $&.downcase!, $_
   else
    puts $_
   end
  end
  warning("no asserts in test", testSuite) if numOfAsserts == 0

  puts "\n  numTests = numTests + 1\n\n"
  puts " end subroutine Test#{testName}\n\n"
 end

 def close
  puts "\n subroutine Setup"
  puts @setup
  puts "  noAssertFailed = .true."
  puts " end subroutine Setup\n\n"

  puts "\n subroutine Teardown"
  puts @teardown
  puts " end subroutine Teardown\n\n"

  puts <<-NEXTONE

 subroutine TS#{@suiteName}( nTests, nAsserts, nAssertsTested, nFailures )

  integer :: nTests
  integer :: nAsserts
  integer :: nAssertsTested
  integer :: nFailures

  continue
  NEXTONE

  @tests.each do |testName|
   puts "\n  call Setup"
   puts "  call Test#{testName}"
   puts "  call Teardown"
  end

  puts <<-LASTONE

  nTests          = numTests
  nAsserts        = numAsserts
  nAssertsTested  = numAssertsTested
  nFailures       = numFailures

 end subroutine TS#{@suiteName}

end module #{@suiteName}TS
  LASTONE
  super
  File.chmod(0444,@suiteName+"TS.f90")
 end

end

####################
# main code follows

checkForCompiler

writeTestRunner(testSuites = parseCommandLine)

# convert each *TS.ftk file into a pure Fortran9x file:

threads = Array.new

testSuites.each do |testSuite|

 threads << Thread.new(testSuite) do |testSuite|

  testSuiteF90 = TestSuite.new(testSuite)

  ftkFile = "#{testSuite}TS.ftk"
  $stderr.puts "parsing #{ftkFile}"

  File.open(ftkFile) do |tsftkFile|

   testSuiteF90.puts $_ until tsftkFile.gets =~ $keyword || !$_
   testSuiteF90.puts " contains\n\n"

   loop do
    case $_
    when $commentLine
     testSuiteF90.puts $_
    when /beginSetup/i
     testSuiteF90.addtoSetup tsftkFile
    when /beginTeardown/i
     testSuiteF90.addtoTeardown tsftkFile
    when /beginTest\s+(\w+)/i
     testSuiteF90.aTest($1,testSuite,tsftkFile)
    when /beginTest/i
     syntaxError "no name given for beginTest", testSuite
    when /end(Setup|Teardown|Test)/i
     syntaxError "no matching begin#$1", testSuite
    when $assertRegEx
     syntaxError "#$1 assert not in a test block", testSuite
    else
     testSuiteF90.puts $_
    end
    break unless tsftkFile.gets
   end

  end

  $stderr.puts "completed #{ftkFile}"
  testSuiteF90.close

 end
end

threads.each{ |thread| thread.join }

runTests testSuites
